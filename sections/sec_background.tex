% !TEX root = ../2021_microservices_wileytemplate.tex

\section{Background}\label{sec:background}

\par Microservices are an architectural style that structures an application as a collection of independent modules. These modules are highly maintainable, testable, loosely coupled, independently deployable, and each isolates a functionality. Therefore, we can split the application into distinct independent services~\cite{thones2015}. Recently, microservice architecture has evolved as a paradigm shift in decomposing large monolithic applications into smaller manageable services with their code base and deployment infrastructure~\cite{Taibi2019}. In microservices, every application function is its service, own container, and communicate via Application programming interface (API)~\cite{Danbettinger2019}.

\par We can describe microservices as simple and stateless. In a microservices world, business requirements are divided into independent features and each of them is built as an individual service when deployed in separate containers. Therefore, it is easy to build and deploy, especially when it is containerized~\cite{Pavlovic2020, Zaytev2018}. Microservices are loosely coupled because they can be developed and released independently of each other. Since services interact over technology-agnostic protocols like HTTP, services could use any technology~\cite{Jaleel2017}. Microservices bring many benefits to applications. Although, service level independent scalability has been considered as the most value-adding advantage for choosing microservices architecture for applications.

\par For several years, a monolithic architecture was the widely-used architecture for building web and mobile applications. The server-side system is based on a single application and easy to develop, deploy, and manage~\cite{Danbettinger2019}. These applications are mostly characterized by individual programs handling multiple functionalities~\cite{Francesco2019}. They often have one database that is shared by all departments. This has the advantage that if we want to make a change in all services, it is enough to implement this change in one place~\cite{Pavlovic2020}. 
%It is this simplicity at the start that seems to be the greatest advantage of monoliths. We do not have to think about the division of services and functions. Though monolithic applications are known to be easier to operate, as the systems grew bigger, they also increased the complexity for coding, deployment, and maintenance stages of the software development life cycle~\cite{Kalske2017, Santos2020}. 
Single point of failure, technology lock-in, and limited scalability are a few other drawbacks of monolithic applications. Growing companies are considering other architecture styles such as microservices~\cite{Lenga2019, Jag2017, Rodrigue2016}. 
%The most common reasons teams migrate to microservices are resilenced and continuous delivery, amongst other challenges~\cite{haugeland2020}.

%\par Adopting microservices comes with a cost~\cite{villamizar2017} at the information technology operational level because of the expenses incurred for deployment, load balancing, process monitoring, and scalability for each service. If not adopted well, one might end up having technical debt. On the other hand, container platforms like docker and kubernetes provide these functions as part of their features~\cite{Sharaf2019, Venugopal2017}. These platforms help in scalability, making it the compelling architecture choice for applications.

%\par Microservices use http as the protocol for synchronous communication and multiple service endpoints may give malicious attackers more opportunities for system penetration. Hence, it is important to secure microservices-based applications with proper authentication and authorization methods~\cite{Jaleel2017, Dragoni2017}.


